---
title: "Preliminares Python y Representación Numérica"
format: 
  html:
    grid:
      body-width: 1200px
---

# Tipos de datos en Python


# Listas

Las listas en Python son estructuras de datos que permiten almacenar múltiples valores en una sola variable. Son mutables, lo que significa que se pueden modificar después de su creación. A continuación, se presentan algunas operaciones básicas con listas.

Crear una lista cuyos elementos sean números, posteriormente aplicar diferentes métodos y funciones de listas.

## Métodos comunes con listas

Método `append()`: Agrega un elemento al final de la lista.

Método `extend()`: Agrega múltiples elementos al final de la lista.

Método `index()`: Devuelve el índice del primer elemento con el valor especificado.

Notemos que Python utiliza índices basados en cero, es decir, el primer elemento de la lista tiene un índice de 0.

Método `reverse()`: Invierte el orden de los elementos en la lista.

Método `sort()`: Ordena los elementos de la lista en orden ascendente.


## Funciones comunes con listas

Función `len()`: Devuelve la longitud (número de elementos) de la lista.

Función `min()`: Devuelve el valor mínimo de la lista.

Función `max()`: Devuelve el valor máximo de la lista.

Función `sum()`: Devuelve la suma de todos los elementos de la lista.

Función `list()`: Convierte un iterable (como una tupla, un rango o una cadena) en una lista.

# Condicionales


# Ciclo for

Aplicar un ciclo `for` a los elementos de una lista.

# Ciclo while


# Módulo math

El módulo `math` en Python proporciona funciones matemáticas definidas por el estándar C. A continuación, se presentan algunas funciones comunes del módulo `math`.

Importar el módulo `math` y utilizar algunas de sus funciones.


```{python}
import math
```

# Funciones

## Función para convertir binario a decimal

Escribir una función llamada `my_bin_2_dec(b)` que convierta un número binario b (representado como una cadena de caracteres) a su equivalente decimal. La función debe tomar una cadena como entrada y devolver un entero como salida. Y comparar el resultado con la función integrada `int(b, 2)`.

```{python}
def my_bin_2_dec(bin):
  bin_lista = list(bin)
  bin_lista.reverse()
  d = 0
  exponente = 0
  for bit in bin_lista:
    d = d + int(bit) * 2**exponente
    exponente +=1
  return d 
```


Prueba

```{python}
my_bin_2_dec("10111")
```


Verificación con la función integrada

```{python}
int("10111",2)
```


## Función para convertir decimal a binario

Escribir una función llamada `my_dec_2_bin(n)` que convierta un número decimal n (entero positivo) a su equivalente binario representado como una cadena de caracteres. La función debe tomar un entero como entrada y devolver una cadena como salida. Y comparar el resultado con la función integrada `bin(n)[2:]`.


```{python}
def my_dec_2_bin(n):
  if n == 0:
    return "0"
  q = n
  binario = []
  while q > 0:
    residuo = q % 2
    binario.append(str(residuo))
    q = q // 2
  binario.reverse()
  return "".join(binario)
```


Prueba

```{python}
my_dec_2_bin(23)
```


Verificación con la función integrada

```{python}
bin(23)[2:]
```




# Representación IEEE 754

```{python}
import struct
numero = 15

bits_64 = struct.unpack('>Q', struct.pack('>d', numero))[0]
binario_64 = f"{bits_64:064b}"

print(binario_64)
```

**Descripción**:

1.  `struct.pack`: Convierte un número de punto flotante a su representación binaria en formato IEEE 754. Los formatos `'>f'` y `'>d'` indican precisión simple y doble, respectivamente.

2.  `struct.unpack`: Interpreta los datos binarios como enteros sin signo (`'>I'` para 32 bits, `'>Q'` para 64 bits).

3.  Formato binario: Los enteros obtenidos se convierten a binarios utilizando una cadena de formato con ceros iniciales (`f"{bits_64:064b}"`).


Brecha entre números


```{python}
import numpy as np
np.spacing(1e9)
```



```{python}
1e9 == 1e9 + np.spacing(1e9)/3
```

Cuando el número es muy grande, la brecha entre números representables también es grande. Por otro lado, cuando el número es pequeño, la brecha entre números representables es pequeña, como se observa a continuación:

```{python}
np.spacing(10)
```

# Errores de redondeo

```{python}
4.9-4.845 == 0.055
```

A pesar que el resultado matemático es correcto, Python no puede representarlo exactamente debido a limitaciones en la representación de números de punto flotante.

```{python}
4.9-4.845
```